Question: What is decorator design pattern?
Answer: Decorator design pattern is used to modify the functionality of an object at runtime. At the same time other instances
of the same class will not be affected by this, so individual object gets the modified behavior. Decorator design pattern is 
one of the structural design pattern (such as Adapter Pattern, Bridge Pattern, Composite Pattern) and uses abstract classes or
interface with composition to implement.

OR 
Reference: (GeeksForGeeks)
Decorator design pattern allows us to dynamically add functionality and behavior to an object without affecting the behavior of other existing objects within the same class. We use inheritance to extend the behavior of the class. This takes place at compile-time, and all the instances of that class get the extended behavior.

Decorator patterns allow a user to add new functionality to an existing object without altering its structure. So, there is no change to the original class.
The decorator design pattern is a structural pattern, which provides a wrapper to the existing class.
The decorator design pattern uses abstract classes or interfaces with the composition to implement the wrapper.
Decorator design patterns create decorator classes, which wrap the original class and supply additional functionality by keeping the class methodsâ€™ signature unchanged.
Decorator design patterns are most frequently used for applying single responsibility principles since we divide the functionality into classes with unique areas of concern.
The decorator design pattern is structurally almost like the chain of responsibility pattern.
Remember: Certain key points are to be taken into consideration that are as follows: 

Decorator design pattern is useful in providing runtime modification abilities and hence more flexible. Its easy to maintain and extend when the amount of choices are more.
The disadvantage of decorator design pattern is that it uses plenty of similar kind of objects (decorators)
Decorator pattern is used a lot in Java IO classes, like FileReader, BufferedReader, etc.
Procedure:

Create an interface.
Create concrete classes implementing the same interface.
Create an abstract decorator class implementing the above same interface.
Create a concrete decorator class extending the above abstract decorator class.
Now use the concrete decorator class created above to decorate interface objects.
Lastly, verify the output

